# TODO

simplify()
    M ∪ L → L ∪ M
    (L ∪ M) ∪ N → L ∪ (M ∪ N)
    ∅ ∪ L → L ∪ ∅ → L
    L+ ∪ Ɛ → L*
    (LM)N → L(MN)
    ƐL → LƐ → L
    ∅L → L∅ → ∅
    L(M ∪ N) → LM ∪ LN
    (M ∪ N)L → ML ∪ NL
    L ∪ L → L
    ∅* → Ɛ
    Ɛ* → Ɛ
    L+ → LL* → L*L

replace simplify() with smart constructors on parser

array access faster than charCodeAt
<https://mrale.ph/blog/2018/02/03/maybe-you-dont-need-rust-to-speed-up-your-js.html>

in README call-out stateless approach
https://twitter.com/snookca/status/1244088929881673734

- https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/

http://bracha.org/executableGrammars.pdf
https://github.com/gbracha/dart-executable-grammars/blob/master/CombinatorialParsing.dart
http://bracha.org/newspeak-parsers.pdf
http://matt.might.net/articles/parsing-with-derivatives/
http://web.archive.org/web/20160909231358/http://www.cs.uwm.edu:80/~dspiewak/papers/derivative-parsing.pdf
https://gist.github.com/vrthra/53d68eda4d3d261e516f77fd97715d3f
http://matt.might.net/papers/might2011derivatives.pdf
https://stackoverflow.com/questions/3203190/regex-any-ascii-character
https://rjlipton.wpcomstaging.com/2020/03/21/star-free-regular-languages-and-logic/